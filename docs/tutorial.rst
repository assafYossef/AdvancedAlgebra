Getting started and examples
==============================================
Introduction
------------
In this tutorial we will go step by step through the process of extending a prime field.\

This tutorial will give a mathematical overview and examples of how to extend a prime field using our library which we implement - "Galwa".\

We assume that the reader has a basic understanding in abstract algebra - groups, rings, fields, order, etc..

Definitions
-----------
What is a prime field?
~~~~~~~~~~~~~~~~~~~~~~~
A prime field is a field that contains a prime number of elements.

We denote a prime field as :math:`F_p` where :math:`p` is a prime number.\

For example :math:`F_5` is a prime field with 5 elements.

:math:`F_5 =` {:math:`0,1,2,3,4`}

What is an extension of a field?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Given a field :math:`F` and a fixed polynomial :math:`f(x)` with coefficients in :math:`F` of degree :math:`n`.\

We define the ideal generated by :math:`f(x)`:

.. math::

    (f(x)) = \{f(x)g(x) | g(x) \in F[x]\}


Then the extension of :math:`F` by :math:`f(x)` is the set:

.. math::

    F[x]/(f(x)) = \{a(x) + (f(x)) | a(x) \in F[x]\}

In other words, the extension of :math:`F` by :math:`f(x)` is the set of all polynomials of degree less than :math:`n` with coefficients in :math:`F`.\

This is an extension of F with dimension :math:`n`. The extension will have :math:`|F|^n` elements.\

In this tutorial we will extend a prime field denoted as :math:`k = F_p` by a fixed polynomial :math:`f(x) \in k[x]` of degree :math:`n`\  using python.

Lets denote the extension as:

.. math::

        l = F_{p^n} = F_p[x]/(f(x)) = \{a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} | f(x)=0, a_i \in F_p\}

And lets denote the multiplicative group of :math:`l` as:

.. math::

    l^x = l - \{0\}

The cardinality in this case will be :math:`p^n`.\  for example :math:`F_3` extended by :math:`f(x) = x^2 + 1` will have :math:`3^2 = 9` elements.

Primitive element
~~~~~~~~~~~~~~~~~~
We define an extension :math:`k/F` as simple if there exists an element :math:`\alpha` in :math:`k` such that :math:`k = F(\alpha)`.\

In other words, every element in :math:`k` can be written as a polynomial in :math:`\alpha` with coefficients in :math:`F`.\
This element is called a primitive element of the extension.

For our extension field :math:`l = F_{p^n}` is simple since it is finite we can assure that a primitive element exists.\

So we can define all elements in multiplicative group :math:`l^x` with the following basis :math:`\{1, \alpha, \alpha^2, ..., \alpha^{n-1}\}`

Embedding :math:`l^x` in :math:`GL_n(F_p)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We want to calculate each element easily or doing some arithmetic between elements without using Euclidean division for polynomials.\

To do so we will embedd each element :math:`a \in l^x` in a matrix :math:`A \in GL_n(F_p)`.\

Then any operation between elements will be done by matrix multiplication, addition, subtraction and inversion.\

To embedd the element we will use our basis and define a linear transformation :math:`\phi_{a}` from :math:`l^x` to :math:`l^x`, by :math:`\phi_{a}(k) = ak` for all :math:`k \in l^x`.

The final matrix columns will be define as the transformation on each basis element.\

.. math::

    A =
    \begin{pmatrix}
        | & | & | & \ldots & | \\
        \mathbf{\phi_{a}(1)} & \mathbf{\phi_{a}(x)} & \mathbf{\phi_{a}(x^2)} & \ldots & \mathbf{\phi_{a}(x^{n-1})} \\
        | & | & | & \ldots & |
    \end{pmatrix}

Where :math:`\phi_{a}(i) = ai` for all :math:`i \in B`.\

.. math::

    B = \{ 1, x, ..., x^{n-1} \} = \left\{ \begin{bmatrix} 1 \\ 0 \\ 0 \\ \vdots \\ 0 \\ 0 \end{bmatrix}, \begin{bmatrix} 0 \\ 1 \\ 0 \\ \vdots \\ 0 \\ 0 \end{bmatrix}, \ldots, \begin{bmatrix} 0 \\ 0 \\ 0 \\ \vdots \\ 1 \\ 0 \end{bmatrix}, \begin{bmatrix} 0 \\ 0 \\ 0 \\ \vdots \\ 0 \\ 1 \end{bmatrix} \right\}



Code examples
-------------
Lets move to the code.

First, we need to install the library, from the base directory of the project run the following command:

    >>> pip install .

We define three classes:

1. PrimeFieldElement - a class that represents an element in a prime field :math:`F_p`

2. FiniteField - a class that represents an extended field :math:`F_{p^n}`

3. FiniteFieldElement - a class that represents an element in an extension field :math:`F_{p^n}`

And some algorithms:

4. Extended Euclidean algorithm - to find the inverse of an element in a prime field.

5. Baby Step Giant Step algorithm - to find the discrete logarithm in a finite field.

PrimeFieldElement
~~~~~~~~~~~~~~~~~
We implemented the class PrimeFieldElement that represents an element in a prime field :math:`F_p`.\

The class gets as an input the element :math:`a` and the prime number :math:`p`.\

Example:

    >>> from galwa import PrimeFieldElement
    >>> a = PrimeFieldElement(3, 5)
    >>> a
    PrimeFieldElement(value= 3,prime= 5
    >>> print(a)
    3 mod 5

Lets define another element:

    >>> b = PrimeFieldElement(4, 5)
    >>> b
    4

We can now perform some arithmetic operations:

    >>> a + b
    PrimeFieldElement(value= 2,prime= 5)
    >>> a - b
    PrimeFieldElement(value= 4,prime= 5)
    >>> a * b
    PrimeFieldElement(value= 2,prime= 5)
    >>> a / b
    PrimeFieldElement(value= 2,prime= 5)
    >>> a ** 2
    PrimeFieldElement(value= 4,prime= 5)
    >>> a**-1
    PrimeFieldElement(value= 2,prime= 5)
    >>> a.inverse
    PrimeFieldElement(value= 2,prime= 5)
    >>> a == b
    False

As seen above, we also implement the inverse property which uses the extended euclidean algorithm to find the inverse of the element.

The inverse can also be calculated by :math:`a^{-1}`.

FiniteField
~~~~~~~~~~~~
We implemented the class FiniteField that represents an extension of a prime field :math:`l = F_{p^n}`.\

The class gets as an input the prime number :math:`p` and the irreducible polynomial :math:`f(x)`.\

Example:

    >>> from galwa import FiniteField
    >>> import numpy as np
    >>> p = 2
    >>> f = np.array([1, 1, 1])  # x^2 + x + 1
    >>> F = FiniteField(p, f)
    >>> F
    FiniteField(p=2, f(x)= 1 + x + x², p=2)

The elements created automaticly upon initialization:

    >>> F.elements
    [FiniteFieldElement(0, f(x)= 1 + x + x², p=2), FiniteFieldElement(1, f(x)= 1 + x + x², p=2), FiniteFieldElement(x, f(x)= 1 + x + x², p=2), FiniteFieldElement(1 + x, f(x)= 1 + x + x², p=2)]

We can change the representation method for printing, representation can be "polynomial", "vector", or "matrix"

The default value is "polynomial":

    >>> F.representation
    'polynomial'
    >>> print(F)
    FiniteField(p= 2, f(x)= 1 + x + x²)

We can change the representation, all elements will be printed in the new representation:

Changing to "vector":

    >>> F.elements_as_vectors()
    >>> F.elements
    [FiniteFieldElement([0 0], f(x) = [1 1 1] p=2), FiniteFieldElement([1 0], f(x) = [1 1 1] p=2), FiniteFieldElement([0 1], f(x) = [1 1 1] p=2), FiniteFieldElement([1 1], f(x) = [1 1 1] p=2)]
    >>> print(F)
    FiniteField(p= 2, f(x)= [1 1 1])

Changing to "matrix":

    >>> F.elements_as_matrix()
    >>> F.elements
    [FiniteFieldElement(None, f(x) = [1 1 1] p=2),
     FiniteFieldElement([[1 0][0 1]], f(x) = [1 1 1] p=2),
     FiniteFieldElement([[0 1][1 1]], f(x) = [1 1 1] p=2),
     FiniteFieldElement([[1 1][1 0]], f(x) = [1 1 1] p=2)]
    >>> print(F) # f(x) stays vector in matrix as well.
    FiniteField(p= 2, f(x)= [1 1 1])

Back to polynomial:

    >>> F.elements_as_polynomials()
    >>> F.elements
    [FiniteFieldElement(0, f(x)= 1 + x + x², p=2), FiniteFieldElement(1, f(x)= 1 + x + x², p=2), FiniteFieldElement(x, f(x)= 1 + x + x², p=2), FiniteFieldElement(1 + x, f(x)= 1 + x + x², p=2)]
    >>> print(F)
    FiniteField(p= 2, f(x)= 1 + x + x²)

Some other properties and methods.

1. To get the order of the field:

    >>> F.order # p=2 f(x) is degree 2, so 2^2 = 4
    4

The order includes the zero element.

2. Getting the generators of the multiplicative group of the field:

We know that generator element is an element whose powers generate all the elements in the field.

:math:`l^x = \{a^i | 0 <= i < |l^x|\}`

So to get all generators in the field

        >>> F.generators
        [FiniteFieldElement(x, f(x)= 1 + x + x², p=2), FiniteFieldElement(1 + x, f(x)= 1 + x + x², p=2)]

What happens in the background is that we check the order of each element in the field, if the order is equal to the order of the multiplicative group then it is a generator.

3. Getting a specific element:

You can give a vector represents an element in the field, and the function will return the element.

        >>> F.get_element(np.array[1, 0])
        FiniteFieldElement(1, f(x)= 1 + x + x², p=2)


FiniteFieldElement
~~~~~~~~~~~~~~~~~~~
We implemented the class FiniteFieldElement that represents an element in the extension field :math:`l = F_{p^n}`.\

The class gets as an input a numpy array that represents the element and the field object that the element belongs to.\

    >>> from galwa import FiniteField, FiniteFieldElement
    >>> import numpy as np
    >>> f = np.array([1, 1, 0, 1])
    >>> p = 2
    >>> field = FiniteField(p, f)
    >>> a = FiniteFieldElement(np.array([1, 0, 1]), field)
    >>> a
    FiniteFieldElement(1 + x², f(x)= 1 + x + x³, p=2)

The default representation is polynomial, but we can change it to vector or matrix:

    >>> a.representation
    'polynomial'
    >>> a
    FiniteFieldElement(1 + x², f(x)= 1 + x + x³, p=2)
    >>> print(a)
    1 + x²

Changing to vector:

    >>> a.as_vector()
    >>> a
    FiniteFieldElement([1 0 1], f(x) = [1 1 0 1] p=2)
    >>> print(a)
    [1 0 1]

Changing to matrix:

    >>> a.as_matrix()
    >>> a
    FiniteFieldElement([[1 0 1]
                        [1 0 0]
                        [0 1 0]], f(x) = [1 1 0 1] p=2)
    >>> print(a)
    [[1 0 1]
    [1 0 0]
    [0 1 0]]

Back to polynomial:

    >>> a.as_polynomial()
    >>> a
    FiniteFieldElement(1 + x², f(x)= 1 + x + x³, p=2)
    >>> print(a)
    1 + x²

Arithmetic operations:

We can make some arithmetic operations between elements:

    >>> from galwa import FiniteField, FiniteFieldElement
    >>> import numpy as np
    >>> f = np.array([1, 1, 0, 1])
    >>> p = 2
    >>> field = FiniteField(p, f)
    >>> a = FiniteFieldElement(np.array([1, 0, 1]), field)
    >>> b = FiniteFieldElement(np.array([1, 1, 0]), field)
    >>> a + b
    FiniteFieldElement(x + x², f(x)= 1 + x + x³, p=2)
    >>> a - b
    FiniteFieldElement(x + x², f(x)= 1 + x + x³, p=2)
    >>> a * b
    FiniteFieldElement(x², f(x)= 1 + x + x³, p=2)
    >>> a / b
    FiniteFieldElement(1 + x, f(x)= 1 + x + x³, p=2)
    >>> a ** 2
    FiniteFieldElement(1 + x + x², f(x)= 1 + x + x³, p=2)
    >>> a**-1
    FiniteFieldElement(x, f(x)= 1 + x + x³, p=2)

Other methods and properties:

1. Getting the multiplicative order of the element:

    >>> a.multiplicative_order()
    7

From lagrange theorem we know that for :math:`H` as subgroup of :math:`G` then the order of any element in :math:`G` divides the order of :math:`G`.\

That is true for all :math:`g \in G , |<g>| | |G|`

In our case the multiplicative group of :math:`F_{p}^x = F_{p} - \{0\}` is a subgroup of the multiplicative group :math:`l^x`.

So for  all :math:`a \in l^x, O(a) | O(l^x)`.

So first, we calculate all divisors of the order of the multiplicative group of the field, the complexity of this operation is :math:`O(\sqrt{n})`\ where :math:`n` is the order of the multiplicative group.

The divisors array will be sorted, we will start from the smallest and calculate :math:`a^{d}` for each divisor :math:`d` and check if the result is the identity element.

Calculating :math:`a^{d}` can be done using exponentiation by squaring algorithm, the complexity of this operation is :math:`O(\log(d))`.

So the complexity in the best case will be :math:`O(\log(d)` and in the worst case :math:`O(k\log(d))` where :math:`k` is the number of divisors.


2. Checking if the element is a generator:

    >>> a.is_generator()
    True

3. Checking if the element is the identity element of :math:`l^x`:

    >>> a.is_identity_of_multiplication()
    False

4. Getting the order of the element:

    >>> a.order
    7

5. Calculate the embedding matrix of the element in :math:`GL_n(F_p)`:

    >>> a.embed_in_gln()
    array([[1, 1, 0],
           [0, 0, 1],
           [1, 0, 0]])

Extended Euclidean algorithm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We implemented the extended Euclidean algorithm to find the inverse of an element in a prime field.\

We know that if the greatest common divisor of two numbers is 1, then they are coprime and the inverse exists.\

We can get the inverse of an element using the extended Euclidean algorithm, and Bozout's identity.\

:math:`ax + by = gcd(a, b)`.\

Example:

    >>> from galwa.utils import xgcd
    >>> d, x, y = xgcd(3, 5)
    >>> d
    1
    >>> x
    2
    >>> y

Baby-step giant-step algorithm
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We implemented the baby-step giant-step algorithm to find the discrete logarithm in a finite field.\

Given a generator :math:`g` and an element :math:`h` in the field, we want to find the exponent :math:`x` such that

:math:`g^x = h`.\

The above expression can be expressed as
:math:`g^{im + j} = h`.\

Where :math:`m` is the giant step and :math:`j` is the baby step.\

Taking :math:`-im` from both sides we get:

:math:`g^{j} = h(g^{-m})^i`.\

Steps:

1. We start from the group order, the group must be cyclic, lets denote the order as :math:`n`.

2. We set the giant step to be the ceiling of the square root of the group order, :math:`m = ceil(\sqrt{n})`.

3. We calculate the baby step table :math:`\{g^j:j , 0 <= j < m\}`.

4. Now for the giant step, we start by defining :math:`g^{-m}` and calculate :math:`h(g^{-m})^i` for all :math:`0 <= i < m`.

5. If the result is in the baby step table, then we found the exponent creates it :math:`x = im + j`.

Code Example:

    >>> from galwa import FiniteFieldElement, FiniteField
    >>> from galwa.utils import bsgs
    >>> import numpy as np
    >>> f = np.array([2, 0, 0, 2, 1])
    >>> p = 3
    >>> F = FiniteField(p, f)
    >>> g = FiniteFieldElement(np.array([1, 1, 0, 0]), F)
    >>> h = g ** 10
    >>> h
    FiniteFieldElement(2, f(x)= 2 + 2·x³ + x⁴, p=3)
    >>> order = F.order - 1
    >>> bsgs(g, h, order)
    10

